#include <iostream>
#include <vector>
#include <limits>
#include <stdlib.h>
#include <math.h>
#include <chrono>
#include <algorithm>

#include<string>
#include <cstring>
#include<fstream>
#include<ostream>

#include <cassert>
#include <stack>
#include <list>

using namespace std;

#define inf numeric_limits<int>::max()

vector<int> test_cases = {2500, 5000, 7500, 10000, 12500};

void init_potentials(vector<vector<int>> &cost, int n, vector<double>& dual_row, vector<double>& dual_col){
	// Init dual row
    for (int i = 0; i < n; i++){
        double temp = inf;
		// Find minimum value of row i
        for (int j = 0; j < n; j++){
            temp = min(temp, double(cost[i][j]));
        }
        dual_row[i] = temp;
    }

	// Init dual col
    for (int j = 0; j < n; j++){
        double temp = inf;
		// Find minimum value of col j
        for (int i = 0; i < n; i++){
            temp = min(temp, cost[i][j] - dual_row[i]);
        }
        dual_col[j] = temp;
    }
}

int optimality_check(int n, vector<bool>& cov_row, vector<int> &ass_row){
    // Calculate the number of assigned resources
    int match_count = 0;
    for (int i=0; i<n; i++){
        if (ass_row[i] != -1){
            cov_row[i] = 1;
            match_count += 1;
        }
    }
    return match_count;
}

void forward_bfs(vector<vector<int>> &cost, int n, vector<int> &f_in, vector<bool>& active, vector<bool>& reverse, vector<bool>& visited, vector<int> &ass_col, vector<bool>& cov_row, vector<bool>& cov_col, vector<double> &dual_row, vector<double> &dual_col, vector<double>& slack, vector<int>& prv_row, vector<int>& prv_col){
	// Breadth-first search that produces a vertex-disjoint tree
	for (int j=0; j<n; j++){
        if (cov_col[j] == 0){
			// Loop over frontier
            for (int x=0; x < f_in.size(); x++){
				// Index of active row
                int i = f_in[x];
				// Check if new slack is smaller than current slack of column j
                if (slack[j] > cost[i][j] - dual_row[i] - dual_col[j]){
					// Update minimum slack value of column j
                    slack[j] = cost[i][j] - dual_row[i] - dual_col[j];
					// Row gets safed as predessecor to j
                    prv_col[j] = i;
                }
				// Get row that is assigned to j
                int i_new = ass_col[j];
                if (slack[j] == 0){
					// Check if i_new is unassigned
                    if (i_new != -1){
                        prv_row[i_new] = j;
                        cov_row[i_new] = 0;
                        cov_col[j] = 1;
                        if (!active[i_new]){
							// Mark i_new as active for next forward_bfs
                            active[i_new] = true;
                        }
                    }
                    else{
						// Mark j as reverse
                        reverse[j] = true;
                    }
                }
				// Mark i as visited
                visited[i] = true;
            }
        }
    }
}

void reverse_bfs(vector<int> &f_rev, vector<bool>& augment, vector<int>& suc_row, vector<int>& suc_col, vector<int> &prv_row, vector<int> &prv_col){
	// Reverse pass to identify alternating, vertex-disjoint paths by traversing the trees generated by the forward_bfs
    for (int x=0; x < f_rev.size(); x++){
        int j = f_rev[x];
        int r_cur = -1;
        int c_cur = j;
		// Traverse tree stored in predecessor vectors
        while (c_cur != -1){
            suc_col[c_cur] = r_cur;
            r_cur = prv_col[c_cur];
            suc_row[r_cur] = c_cur;
            c_cur = prv_row[r_cur];
        }
		// Mark r_cur for augment pass
        augment[r_cur] = true;
    }
}

void augment_pass(vector<int> &f_aug, vector<int>& ass_row, vector<int>& ass_col, vector<int> &suc_row, vector<int> &suc_col){
	// Augment pass to augment the assignment
    for (int x=0; x < f_aug.size(); x++){
        int i = f_aug[x];
        int r_cur = i;
        int c_cur = -1;
		// Traverse tree stored in successor vectors
        while (r_cur != -1){
            c_cur = suc_row[r_cur];
            ass_row[r_cur] = c_cur;
            ass_col[c_cur] = r_cur;
            r_cur = suc_col[c_cur];
        }
    }
}

void update_pass(int n, vector<bool>& active, vector<bool> &cov_row, vector<bool> &cov_col, vector<double>& dual_row, vector<double>& dual_col, vector<double>& slack, vector<int> &prv_col){
    // Find minimum non-zero slack
	double theta = inf;
    for (int j=0; j<n; j++){
        if (slack[j] > 0){
            theta = min(theta, slack[j]);
        }
    }
	
	// Update dual variables and slack
    for(int k=0; k<n; k++){
        if (cov_row[k] == 0){
            dual_row[k] = dual_row[k] + theta/2;
        }
        else{
            dual_row[k] = dual_row[k] - theta/2;
        }
        if (cov_col[k] == 0){
            dual_col[k] = dual_col[k] + theta/2;
        }
        else{
            dual_col[k] = dual_col[k] - theta/2;
        }
        if (slack[k] > 0){
            slack[k] = slack[k] - theta;
			// Mark predecessor rows with zero slack as active
            if (slack[k] == 0){
                active[prv_col[k]] = true;
            }
        }
    }
}

bool augmenting_path_search(vector<vector<int>> &cost, int n, vector<bool>& active, vector<int>& ass_row, vector<int>& ass_col, vector<bool>& cov_row, vector<bool>& cov_col, vector<double>& dual_row, vector<double>& dual_col, vector<double>& slack, vector<int>& prv_row, vector<int>& prv_col, vector<int>& suc_row, vector<int>& suc_col){

    bool check_flag = false;
	// Init vectors to store which indices should be added to the frontiers
    vector<bool> visited(n, false);
    vector<bool> reverse(n, false);
    vector<bool> augment(n, false);
	// Init frontiers
    vector<int> f_in;
    vector<int> f_rev;
    vector<int> f_aug;

	// Set unassigend rows to active and assigned rows to inactive
    for (int i=0; i<n; i++){
        if (ass_row[i] == -1||active[i]){
            active[i] = true;
        }
        else{
            active[i] = false;
        }
    }

	// Repeat forward_bfs until there are no more active rows
    while (true){
		// Init frontier for forward_bfs
        f_in.clear();
        int active_count = 0;
        for (int i=0; i<n; i++){
            if(visited[i]){
				active[i] = false;
	    } 
			if(active[i]){
                f_in.push_back(i);
                active_count += 1;
            }
        }
		// Check if any active rows are left
        if (active_count == 0){
            break;
        }

        forward_bfs(cost, n, f_in, active, reverse, visited, ass_col, cov_row, cov_col, dual_row, dual_col, slack, prv_row, prv_col);
    }

	// Init frontier for reverse_bfs
    for (int j=0; j<n; j++){
        if (reverse[j] == true){
            f_rev.push_back(j);
        }
    }

	// Check if any columns were marked for reverse_bfs
    if (f_rev.size() > 0){
		
        reverse_bfs(f_rev, augment, suc_row, suc_col, prv_row, prv_col);
		
		// Init frontier for augment pass
        for (int j=0; j<n; j++){
            if (augment[j] == true){
                f_aug.push_back(j);
            }
        }

        augment_pass(f_aug, ass_row, ass_col, suc_row, suc_col);
		// Set flag which indicates if optimality check should be executed (True) or not (False)
        check_flag = true;
    }
    else{
		// If reverse pass wasn't executed update dual variables to introduce new zero slack
        update_pass(n, active, cov_row, cov_col, dual_row, dual_col, slack, prv_col);
		// Set flag which indicates if optimality check should be executed (True) or not (False)
        check_flag = false;
    }
    return check_flag;
}

int hungarian_serial(vector<vector<int>> &cost, int n){
	// Init variables
    int ret = 0; //weight of the optimal matching
    vector<int> ass_row(n, -1); //row assignment
    vector<int> ass_col(n, -1); //col assignment
    vector<bool> cov_row(n, -1); //row cover
    vector<bool> cov_col(n, -1); //col cover
    vector<double> dual_row(n); //dual variable row
    vector<double> dual_col(n); //dual variable col
    vector<double> slack(n, inf); //column slack variable
    vector<int> prv_row(n, -1); //row predecessor
    vector<int> prv_col(n, -1); //col predecessor
    vector<int> suc_row(n, -1); //row successor
    vector<int> suc_col(n, -1); //col successor

    vector<bool> active(n, false);
    bool check_flag = true;
	

	init_potentials(cost, n, dual_row, dual_col);
    while (true){
        if(check_flag){
            //reset Cover Arrays and Predecessor Arrays to initial state
            for (int i=0; i<n; i++){
                cov_row[i] = 0;
                cov_col[i] = 0;  
                prv_row[i] = -1;
                prv_col[i] = -1;
                slack[i] = inf;
                suc_row[i] = -1;
                suc_col[i] = -1;
            }

            int match_count = optimality_check(n, cov_row, ass_row);
			
			// Terminate if all rows are assigned
            if (match_count == n){
                break;
            }
        }

        check_flag = augmenting_path_search(cost, n, active, ass_row, ass_col, cov_row, cov_col, dual_row, dual_col, slack, prv_row, prv_col, suc_row, suc_col);
    }

	// Calculate total cost of assignment
    for (int i = 0; i < n; i++) {
        ret += cost[i][ass_row[i]];
    }

    return ret;
}

void create_matrix(vector<vector<int>>& mat, int size){
	srand (time(NULL)); 
	
	mat.resize(size);
	for(int i=0;i<size;++i){
        mat[i].resize(size);
        for(int j=0;j<size;++j){
            mat[i][j] = rand() % size + 1;
        }
    }
}

double median(vector<double> v, int n)
{
    // Sort the vector
    sort(v.begin(), v.end());

    // Check if the number of elements is odd
    if (n % 2 != 0)
        return (double)v[n / 2];

    // If the number of elements is even, return the average
    // of the two middle elements
    return (double)(v[(n - 1) / 2] + v[n / 2]) / 2.0;
}

int main(int argc, char*argv[])
{
    if (argc != 3) {
        std::cerr << "Arguments must be presented as follows." << std::endl;
        std::cerr << "./name_test num_test_runs name_output_file" << std::endl;
        exit(1);
    }
	
	string output_path = "./data/";
	output_path.append(argv[2]);
	string filename_all_runs = output_path + ".txt";
	string filename_mean_runs = output_path + "_mean.txt";
	
	int num_test_runs = atoi(argv[1]);
	
	ofstream out_file_all;
    out_file_all.open (filename_all_runs);
	out_file_all<<"Hungarian Serial : \n";
	out_file_all<<"Size\t\t\t\tCost\t\t\t\tTotal Time in s\t\t\tTotal CPU time in ms\n";
	
	ofstream out_file_mean;
    out_file_mean.open (filename_mean_runs);
	out_file_mean<<"Hungarian Serial ("<<num_test_runs<<" runs): \n";
	out_file_mean<<"Size\t\t\t\tMean Time in s\t\t\tMean CPU time in ms\t\t\tMedian Time in s\t\t\tMedian CPU Time in ms\n";
	
	for (int& n : test_cases){ // n is the number of jobs and workers
		double sum_timing = 0;
		double sum_time = 0;
		vector<double> times(test_cases.size());
        vector<double> timings(test_cases.size());

		for (int r=0; r < num_test_runs; r++){
			cout<<"Test Case:\t"<<n<<endl;
			/* init cost matrix for test case */
			vector<vector<int>> cost; //cost matrix
			create_matrix(cost, n);

			int res; // result of algorithm
			clock_t start, end; // start and end time of algorithm

			/* Begin Time */
			auto t1 = std::chrono::high_resolution_clock::now();
			start = clock();

			res=hungarian_serial(cost, n); 
			end = clock();
		
			/* End Time */
			auto t2 = std::chrono::high_resolution_clock::now();
			double timing = std::chrono::duration_cast<std::chrono::milliseconds>(t2-t1).count();
			double time = (double) (end-start) / CLOCKS_PER_SEC * 1000.0;
			
			times.push_back(time);
			timings.push_back(timing);
				
			sum_timing += timing;
			sum_time += time;

			out_file_all<<n<<"\t\t\t\t"<<res<<"\t\t\t\t"<<timing / 1000.0<<"\t\t\t\t"<<time<<"\n";
		}
		
		double mean_timing = sum_timing / num_test_runs;
		double mean_time = sum_time / num_test_runs;
		
		double median_timing = median(timings, timings.size());
		double median_time = median(times, times.size());
		
		out_file_mean<<n<<"\t\t\t\t"<<mean_timing / 1000.0<<"\t\t\t\t"<<mean_time<<"\t\t\t\t"<<median_timing / 1000.0<<"\t\t\t\t"<<median_time<<"\n";
	}
	out_file_all.close();
	out_file_mean.close();
}
